#!/usr/bin/env python
# coding: utf-8

# In[2]:


# （必須）モジュールのインポート
import os
import numpy as np
import pandas as pd
import matplotlib as mpl
import matplotlib.pyplot as plt

# 表示設定
np.set_printoptions(suppress=True, precision=3)
get_ipython().run_line_magic('precision', '3')


# # NumPyの基礎

# 本章は以下の文献とウェブサイトを参考にしています：
# 
# - Wes McKinney, Pythonによるデータ分析入門，オライリー，2018
# - Jake VanderPlas, Pythonデータサイエンスハンドブック，オライリー，2018
# - note.nkmk.me: https://note.nkmk.me

# ## Numpyとは？

# ### NumPyとは？

# スポーツのデータセットは画像，ドキュメント，座標，など様々なフォーマットを持つが，これらは数値や文字列を格納した配列として扱うことができる．例えば，試合を撮影した動画はフレーム単位ではデジタル画像として表されている．デジタル画像は2次元配列として表され，配列の各要素が各ピクセルの輝度（RGB値）に対応している．また，選手の位置座標は $(x, y, z)$ の時系列データとなっているので，各座標成分の時系列データとして扱えば，2次元配列として表すことができる．

# このように，データ分析では，数値や文字列を効率的に格納することが必要となる．Pythonには，配列を扱うためのリストという機能が標準搭載されているが，サイズの大きいデータを扱うのには不向きである．そこで，大規模な配列を高速に処理するためのライブラリとしてNumPy（ナンパイ）が用意されている．NumPyの配列はPythonの組み込みリストと似ているが，配列のサイズが大きくなるにつれて，より効率的なデータ操作ができるように設計されている．

# ### NumPyのimport
# 
# NumPyは`np`という名前で以下のようにimportするのが慣例である：

# In[2]:


import numpy as np


# これにより，NumPyの関数（例えば`func`関数）を使うときには`np.func()`のように実行できる．

# ### Numpy配列とリストの違い
# 
# #### リスト
# Pythonのリストは以下のように整数と文字列など複数の型を同時に格納することができ，多次元にすることも可能である．
# また，行ごとに異なるサイズにすることもできる．

# In[3]:


[[1, 'a', 10.0], [2, 'b']]


# #### NumPy配列
# 
# NumPy配列を生成する方法は後ほど詳しく説明するが，`np.array`関数を用いて組み込みリストを変換するのが基本である．

# In[4]:


np.array([[1, 2], [3, 4]])


# NumPy配列は組み込みリストと同様に多次元配列を実現できるが，**全ての要素が同じ型を持ち，各行のサイズも同じでなければならない**という制約がある（データ型をobjectにすれば実現できなくもないが，これは用いるべきではない）．
# 一見するとPythonの組み込みリストの方が使い勝手が良いように見えるが，Numpy配列には以下のような長所があるため，特に大規模な数値データを扱う際に威力を発揮する．

# **1. リストに比べて高速に動作する**
# 
# Numpyの内部はC言語によって実装されているため，特に大規模なデータを扱う際にリストとの違いが顕著になる．
# 以下は0から9999まで1ずつ増える配列をリストとNumpy配列で生成する例である．
# 
# ※マジックコマンド`%%time`を使用することで，セル全体のコードの実行時間を測定することができる．

# In[152]:


get_ipython().run_cell_magic('time', '', 'x_list = []\nfor i in range(10000):\n    x_list.append(i)\nprint(np.array(x_list))\n')


# In[153]:


get_ipython().run_cell_magic('time', '', 'x_numpy = np.arange(10000)\nprint(x_numpy)\n')


# **2. 配列全体に対する高速な演算が可能でコードがシンプル**
# 
# この機能はユニバーサル関数と呼ばれ，配列に対して演算を行うだけでそれが各要素に適用されるのでコードがシンプルになる．
# リストで同じ結果を得るためにはfor文を使う必要があるが，pythonではループ処理が非常に遅くかつコードが煩雑になる．
# 以下は，配列の各要素を2倍するコードをリストとNumpy配列で実装した例である．

# In[154]:


get_ipython().run_cell_magic('time', '', 'for i in range(len(x_list)):\n    x_list[i] = x_list[i] * 2\nprint(np.array(x_list))\n')


# In[155]:


get_ipython().run_cell_magic('time', '', 'x_numpy = x_numpy * 2\nprint(x_numpy)\n')


# **3. 高速に動作する関数やメソッドが利用可能**
# 
# 例えば配列をソートしたいとき，NumPyや類似のパッケージを使わない場合は自分でソート関数を作る必要があるが，それがエラーなく高速に動く保証はない．
# 一方，NumPyには予め`np.sort`関数が用意されているためこれを用いるだけで済み，さらにアルゴリズムを選択することもできる．

# In[156]:


# 0~10までの整数をランダムに生成して，ソートする
a = np.random.randint(0, 100, 10)
np.sort(a)


# ### NumPy配列のデータ型

# `np.array`関数でデータ型を明示的に指定したい場合には`dtype`キーワードを用いる．`dtype`で指定できる主要なデータ型は以下の通りである：
# 
# - `int`（整数）
# - `float`（浮動小数点数）
# - `bool`（真偽値：`True`／`False`）
# 
# より詳しく`float64`のようにビット長を指定することもできるが省略するとデフォルトのビット長が指定される．なお，文字列を扱いたい場合はNumpyではなくリストかPandasを用いるのが良い．

# In[160]:


x = np.array([1,2,3,4], dtype='int')
x


# In[161]:


x = np.array([1,2,3,4], dtype='float')
x


# 既存のNumPy配列に対してデータ型を変更したい場合は`astype`メソッドを用いる．

# In[163]:


# データ型を整数に変更
x = x.astype(int)
x.dtype


# ### NumPy配列の属性
# 
# NumPy配列の形状や要素数などを属性と呼ぶ．
# NumPy配列は以下のような属性を持つ：
# - `shape`：配列の形状
# - `ndim`：配列の次元数
# - `size`：配列の全要素数
# - `dtype`：配列のデータ型
# 
# 配列`x`に対して`x.shape`などとすると，対応する属性を取得することができる．

# In[169]:


# 配列の作成
x1 = np.array([1,2,3,4,5,6])
print(x1)
x2 = np.array([[1,2,3], [4,5,6], [7,8,9]]).astype(float)
print(x2)


# In[170]:


# 配列の形状
print(x1.shape)
print(x2.shape)


# In[171]:


# 次元数
print(x1.ndim)  # 1次元
print(x2.ndim)  # 2次元


# In[172]:


# 配列の全要素数
print(x1.size)
print(x2.size)


# In[173]:


# 配列のデータ型
print(x1.dtype)
print(x2.dtype)


# ### 演習問題
# 
# - `np.array`関数を用いて様々なデータ型の配列を作成せよ
# - 作成した配列について，いくつかの属性を取得せよ
# - `astype`メソッドを用いて，作成した配列のデータ型を変更せよ
# - `dtype`メソッドを用いて，変更した配列のデータ型を確認せよ

# ## ベクトルと行列について

# データ分析をする上でベクトルと行列の演算（つまり線形代数）は避けて通ることができない．実は，NumPyはベクトルや行列を扱うためのパッケージといっても過言ではない．以下，ベクトルと行列について簡単に説明する．

# ### ベクトル
# 
# 以下のように数字を1方向に並べたものをベクトルと呼ぶ：
# 
# $$
#     \left(
# 	\begin{array}{c}
# 		 1 \\
#          2 \\
#          3
# 	\end{array}
# \right),\hspace{0.5cm}
#     (1, 2, 3, 4)
# $$
# 
# １つ目は数字が縦に並んでいるので縦ベクトル，２つ目は横ベクトルと呼ぶ．

# ベクトルを構成する各要素を成分と呼ぶ．例えば，上の縦ベクトルは第0成分が1，第1成分が2，第2成分が3である．NumPyでは，横ベクトルは1次元のNumPy配列，縦ベクトルは2次元のNumPy配列によって以下のように実現できる：

# In[174]:


np.array([1,2,3])


# In[175]:


np.array([[1], [2], [3]])


# $(a_{1}, a_{2})$というベクトルは，$xy$平面上の任意の点から$x$方向に$a_{1}$，$y$方向に$a_{2}$進んだ点まで引いた矢印によって可視化できる．つまり，ベクトルというのは向きと長さ（大きさ）を持った量である．ベクトルの大きさは矢印の始点から終点までの距離に対応するので
# 
# $$
#     \sqrt{a_{1}^{2} + a_{2}^{2}}
# $$
# 
# と表される．
# スポーツデータの分析では，選手の速度を求めることがよくあるが，速度というのは向きと大きさを持つ量であるので，速度ベクトルとして表すことができる．

# ### 行列

# ベクトルは数字を一方向に並べたものであったが，以下のように数字を縦と横に並べたものを考える：
# 
# $$
#     \left(
# 	\begin{array}{ccc}
# 		 3 & 5 & 7 \\
#          1 & 0 & 9 \\
#          2 & 4 & 3
# 	\end{array}
# \right)
# $$
# 
# これを行列と呼ぶ．

# 行列はベクトルを並べたものと捉えることもできる．
# 上の行列を横方向に切ると，以下のように３つのベクトルに分割することができる：
# 
# $$
#     \left(
# 	\begin{array}{c}
# 		 3 & 5 & 7
# 	\end{array}
# \right),
#     \left(
# 	\begin{array}{c}
# 		 1 & 0 & 9
# 	\end{array}
# \right),
# \left(
# 	\begin{array}{c}
# 		 2 & 4 & 3
# 	\end{array}
# \right)
# $$
# 
# これらを**行**と呼び，それぞれを0から始まる行番号によって0行，1行，2行などという．
# NumPyおよびPandasでは，行番号が増減する軸を`axis=0`と表す．

# 一方，行列を縦方向に切ると
# 
# $$
#     \left(
# 	\begin{array}{ccc}
# 		 3 \\
#          1 \\
#          2
# 	\end{array}
#     \right),\hspace{0.5cm}
#     \left(
# 	\begin{array}{ccc}
# 		 5 \\
#          0 \\
#          4
# 	\end{array}
#     \right)\hspace{0.5cm}
#     \left(
# 	\begin{array}{ccc}
# 		 7 \\
#          9 \\
#          3
# 	\end{array}
#     \right)
# $$
# 
# に分割することができる．
# これを**列**と呼び，0から始まる列番号によって0列，1列，2列などという．
# NumPyおよびPandasでは，列番号が増減する軸を`axis=1`と表す．

# 行列の形状は行数と列数の組み合わせで $ 3\times 3 $ 行列などと表す（1つ目の3は行数，2つ目の3は列数）．また，行列の成分は行番号 $ i $ と列番号 $ j $ を用いて $ (i, j) $ 成分などと表す．例えば，上の行列の $(0, 1)$ 成分は2である．

# 行列は2次元のNumPy配列によって以下のように実現できる：

# In[177]:


np.array([[3, 5, 7], [1, 0, 9], [2, 4, 3]])


# ```{figure} ../figure/matrix.png
# ---
# height: 200px
# name: fig:matrix
# ---
# 行列の例
# ```

# ## NumPy配列の生成

# NumPy配列を生成するには，主にリストを変換する方法と配列生成関数を使う方法がある．

# ### リストを変換する
# 
# リストからNumPy配列を作るには，`np.array`関数を用いる

# In[178]:


np.array([1,2,3,4])


# In[179]:


# 3x2行列
np.array([[1,2], [3, 4], [5, 6]])


# もし，各要素の型が一致しない場合，以下のように自動的に型が統一される

# In[180]:


np.array([1, 2.0, 3])


# ### 配列生成関数を使う
# 
# 予めリストが与えられている場合や配列の要素が分かっていてサイズが小さい場合には上の方法で問題ないが，それ以外の場合にはNumPyの配列生成関数を利用するのが良い．

# #### 等間隔の数列を作成する
# 
# まず，等間隔の数列を作る関数として，`np.arange()`と`np.linspace()`がある．
# - `np.arange(start, end, step)`
#   - `start`以上`end`未満の範囲で`step`間隔の数列を生成する．
# - `np.linspace(start, end, num)`
#   - `start`から`end`の間を`num`等分した数列を生成する．
# 
# この２つはNumPyの関数の中でも特に多用するので覚えておいた方が良い．

# In[181]:


# 0以上20未満の範囲で2ずつ増加する数列
np.arange(0, 20, 2)


# In[182]:


# endだけを指定する
np.arange(10)


# In[183]:


# 0から1までを5分割した数列
np.linspace(0, 1, 5)


# #### 規則的な配列を生成する
# 
# 以下のように，規則的な配列（全ての要素が同じ値であるなど）を生成する関数も用意されている：
# - `np.zeros(shape)`
#   - 全ての要素が0の`shape`形状の配列を生成する．
# - `np.ones(shape)`
#   - 全ての要素が1の`shape`形状の配列を生成する．
# - `np.full(shape, fill_value)`
#   - 全ての要素が`fill_value`の`shape`形状の配列を生成する．

# In[184]:


# 要素が全て0である長さ10の整数配列
np.zeros(10, dtype=int)


# In[185]:


# 要素が全て1である3行5列の浮動小数点数配列
np.ones([3, 5], dtype=float)


# In[186]:


# 要素がすべて100である3x5配列
np.full([3, 5], 100)


# 以上の関数について，既存の配列`x`と同じ形状にしたい場合は`np.zeros_like(x)`, `np.ones_like(x)`, `np.full_like(x)`を用いる．

# In[187]:


x = np.array([[1, 2, 3], [4, 5, 6]])


# In[190]:


np.zeros_like(x)


# In[188]:


np.ones_like(x)


# In[189]:


np.full_like(x, 5)


# #### ランダムな配列（乱数）
# 
# ランダムな値（乱数）を生成する関数も用意される．以下に一例を示す．

# In[191]:


# 0以上1未満の一様実数乱数を要素とする3x4配列
np.random.random_sample([3, 4])


# In[192]:


# 10以上20未満の一様整数乱数を要素とする3x4配列
np.random.randint(10, 20, [3, 4])


# In[193]:


# 平均5，標準偏差0.5の正規乱数を要素とする3x4配列
np.random.normal(5, 0.5, [3, 4])


# もし，乱数を生成する際にシードを指定したい場合は`np.random.seed`関数を用いる．
# `np.random.seed(seed=10)`のようにシード値を指定することで，再現性のある乱数を生成することができる（何度実行しても同じ乱数が生成される）．

# In[195]:


np.random.seed(seed=10)
np.random.randint(0, 100, 10)


# ### 演習問題

# 以下の配列を生成せよ：
# ```python
# # 0から100まで2ずつ増加する数列
# [0, 2, 4, ..., 96, 98, 100]
# ```

# In[ ]:


# NumPyを使わずに


# In[ ]:


# NumPyを使って


# In[ ]:


# 作成した配列の要素数を取得


# 以下の配列を生成せよ：
# ```python
# # 要素が全て5である3x4配列
# [[5, 5, 5, 5],
#  [5, 5, 5, 5],
#  [5, 5, 5, 5]]
# ```

# In[ ]:


# NumPyを使わずに


# In[ ]:


# NumPyを使って


# In[ ]:


# 作成した配列の形状を取得


# 以下の配列をNumPyを使って生成せよ

# In[ ]:


# -1以上1未満の範囲で0.1ずつ増加する配列


# In[ ]:


# 10から2まで2ずつ減少する配列


# In[ ]:


# 0から10までを3分割した配列


# In[ ]:


# 要素が全て0である5x1の浮動小数配列


# In[ ]:


# 要素が全て1である2x7の整数配列


# In[ ]:


# 要素が全て0.5である長さ10の1次元配列


# 以下の配列`x`と同じ形状の配列を生成せよ

# In[38]:


np.random.seed(seed=5)
x = np.random.rand(15, 7)
print(x)


# In[ ]:


# xの形状を取得


# In[ ]:


# xのデータ型を取得


# In[ ]:


# xと同じ形状で全ての要素が0


# In[ ]:


# xと同じ形状で全ての要素が1


# In[ ]:


# xと同じ形状で全ての要素が3


# ## NumPy配列の操作

# ### 配列のインデックス参照
# 
# 配列中の要素が先頭から何番目かを表す番号を**インデックス**と呼ぶ．
# 1次元配列は1つのインデックス，2次元配列は2つのインデックス（行番号と列番号に対応するインデックス）によって指定する．
# Pythonでは**インデックスが0から始まる**ことに注意する．
# 
# インデックスを用いて配列の一部分を取り出すことを**インデックス参照**と呼ぶ．
# NumPy配列に対するインデックス参照の方法はリストと同様であり，必要なインデックスを角カッコ`[]`で指定することで $i$ 番目要素にアクセスできる．

# #### 1次元配列の場合

# In[2]:


x1 = np.array([1,2,3,4,5,6])
x1


# In[3]:


# 0番目要素
x1[0]


# In[4]:


# 4番目要素
x1[4]


# 配列の末尾から $ i $ 番目の要素にアクセスするには負のインデックスを用いる．

# In[199]:


# 末尾の要素
x1[-1]


# #### 2次元配列の場合

# 2次元配列では，カンマで区切って`arr[0, 0]`のようにアクセスする．
# 行番号→列番号の順番で指定する．
# 
# ※ `arr[0][0]`のように指定することもできるが非推奨．

# In[5]:


x2 = np.array([[1,2,3], [4,5,6]]).astype(float)
x2


# In[6]:


# (0, 1)要素
x2[0, 1]


# In[7]:


# (1, 0)要素
x2[1, 0]


# #### 複数要素の参照（ファンシーインデックス参照）
# 
# インデックス参照の際にインデックスをリストにすることで，複数の要素をまとめて参照することができる．
# これをファンシーインデックス参照と呼ぶ．
# 詳しくは付録を参照のこと：{ref}`numpy_fancy_index`

# In[10]:


x1 = np.random.randint(100, size=10)
x1


# In[11]:


# 3, 4, 7番目の要素
x1[[3, 4, 7]]


# In[12]:


x2 = np.random.randint(100, size=(5, 5))
x2


# In[13]:


# 第0行と第2行
x2[[0, 2]]


# ### 配列のスライス
# 
# 配列中の連続する要素を取り出す操作を**スライス**と呼ぶ．
# NumPyでは，以下のようなコロン`:`を用いた表記により配列の連続する要素を取り出すことができる：
# 
# `x[i_start: i_end: step]`
# 
# ここで，`i_start`は始めのインデックス，`i_end`は終わりのインデックス，`step`は間隔を表す．
# `i_start`，`i_end`，`step`のいずれかが指定されていない場合はデフォルト値として，`i_start=0`，`i_end=その次元のsize`，`step=1`が指定される．
# 通常は`step`を省略する．

# #### 1次元配列のスライス

# In[16]:


x = np.arange(10)
x


# In[17]:


# インデックスが0以上5未満の要素
x[0:5]


# In[18]:


# インデックスが0以上5未満の要素（startの省略）
x[:5]


# In[19]:


# インデックスが5以上の要素（endの省略）
x[5:]


# In[20]:


# 先頭から1つおき（startとendの省略）
x[::2]


# In[22]:


# インデックス1からスタートして1つおき（endの省略）
x[1::2]


# `step`が負の場合，`i_start`と`i_end`のデフォルト値が入れ替わるので，配列を逆順にすることができる．

# In[23]:


# 逆順にすべての要素
x[::-1]


# #### 2次元配列のスライス
# 
# 2次元配列の場合は，行番号と列番号をカンマで区切って指定する．

# In[24]:


x2 = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12], [13, 14, 15]])
x2


# In[25]:


# 0~1行かつ0~1列
x2[0:2, 0:2]


# #### 行の抽出
# 
# 2次元配列で行を抽出する場合には単に行番号を指定するだけで良い．

# In[26]:


# 第1行
x2[0]


# In[27]:


# 1行おき
x2[0::2]


# In[28]:


# 1行目以降
x2[1:]


# #### 列の抽出
# 
# 2次元配列で列を抽出する場合には，行方向にはコロン`：`を指定し，列方向に抽出したい列番号を指定する．

# In[29]:


# 第0列
x2[:, 0]


# In[30]:


# 1列目以降
x2[:, 1:]


# ### 配列への代入

# インデックス参照やスライスによって抽出した配列要素に代入すると，元の配列が変更される．
# この機能を用いると，NumPy配列の一部分を変更することができる．

# #### 1次元の場合

# In[44]:


x1 = np.arange(10)
x1


# In[45]:


# 2番目要素を-2に変更
x1[2] = -2
x1


# In[46]:


# 0~4番目要素までを-1に変更
x1[0:5] = -1
x1


# #### 2次元の場合

# In[47]:


x2 = np.array([[1,2,3], [4,5,6], [7,8,9]])
x2


# In[48]:


# (0,0)成分を12に変更
x2[0, 0] = 12
x2


# In[49]:


# 第1行を[-4, -5, -6]に変更
x2[1] = [-4, -5, -6]
x2


# In[50]:


# 第2列を[10, 20, 30]に変更
x2[:, 2] = [10, 20, 30]
x2


# ### 演習問題

# 以下の配列`x`に対し，インデックス参照とスライスを用いて指定された１部分を抽出せよ．

# In[51]:


np.random.seed(seed=10)
x = np.random.randint(0, 100, [5, 10])
x


# In[ ]:


# (3,7)成分


# In[ ]:


# 第1行


# In[ ]:


# 第5列


# In[ ]:


# 0~2行かつ5列以降


# 配列への代入によって以下の配列を作成せよ

# ```python
# # 中央だけ0
# array([[1., 1., 1.],
#        [1., 0., 1.],
#        [1., 1., 1.]])
# ```

# In[ ]:





# ```python
# # 第2行だけ連番
# array([[0., 0., 0., 0., 0.],
#        [0., 0., 0., 0., 0.],
#        [1., 2., 3., 4., 5.]])
# ```

# In[ ]:





# ```python
# # 第1列だけ-1で後は10
# array([[10, -1, 10],
#        [10, -1, 10],
#        [10, -1, 10],
#        [10, -1, 10],
#        [10, -1, 10]])
# ```

# In[ ]:





# 以下の配列`x`を基に指定された配列を作成せよ

# In[72]:


x = np.arange(0, 25).reshape(5, 5)
x


# ```python
# # 真ん中だけ抽出
# array([[ 6,  7,  8],
#        [11, 12, 13],
#        [16, 17, 18]])
# ```

# In[ ]:





# ```python
# # 逆順
# array([[24, 23, 22, 21, 20],
#        [19, 18, 17, 16, 15],
#        [14, 13, 12, 11, 10],
#        [ 9,  8,  7,  6,  5],
#        [ 4,  3,  2,  1,  0]])
# ```

# In[ ]:





# ## 条件付き抽出

# ### ブールインデックス参照

# #### ブールインデックス参照とは？

# 次のような任意の配列を考える．

# In[52]:


x1 = np.random.randint(0, 100, 5)
x1


# この配列と同じ形状で各要素が`True`または`False`である以下のような配列を用意する：

# In[53]:


index_bool = np.array([False, True, False, True, False])
index_bool


# このような配列を**ブールインデックス配列**と呼び，そのデータ型はbool型である．
# 元の配列`x1`に対して，ブールインデックスを用いて参照すると，`True`の要素だけを抽出することができる．これを**ブールインデックス参照**と呼ぶ．

# In[54]:


# Trueの要素だけ抽出
x1[index_bool]


# #### ブールインデックス参照による条件付き抽出

# ブールインデックスは比較演算子`<`, `>`, `==`, `!=`, `%`などを用いて元の配列から自動的に取得することができる．
# 例えば，配列`x1`の中で値が50未満の要素だけ抽出したい場合には以下のようにする：

# In[55]:


x1 = np.random.randint(0, 100, 20)
x1


# In[56]:


# ブールインデックスの取得
x_bool = (x1 < 50)
x_bool


# In[57]:


# 50未満の要素の抽出
x1[x_bool]


# In[58]:


# 50未満の要素の抽出（条件を直接指定）
x1[x1 < 50]


# ブールインデックス参照は多次元配列でも同様の方法で実現できる．
# また，比較演算子を変えれば，以下のように様々な条件で要素を抽出することができる．

# In[59]:


x2 = np.arange(35).reshape(5, 7)
x2


# In[60]:


# 10未満
x2[x2 < 10]


# In[61]:


# 10以上
x2[x2 >= 10]


# In[62]:


# 2に等しくない
x2[x2 != 2]


# In[63]:


# 2に等しい
x2[x2 == 2]


# In[64]:


# 2で割り切れる
x2[x2 % 2 == 0]


# 以下のように複数の条件を指定することもできる．ただし，各条件は括弧`()`で囲む．

# In[65]:


# 1より大きくかつ5未満の要素
x2_bool = (x2 > 1) & (x2 < 5)
x2_bool


# In[66]:


x2[x2_bool]


# In[67]:


# 1または5
x2[(x2 == 1) | (x2 == 5)]


# #### ブールインデックス参照による代入

# ブールインデックス参照による条件抽出と代入を組み合わせれば，配列の中で条件を満たす要素だけ値を変更することができる．

# In[68]:


x1 = np.arange(-5, 10, 1)
x1


# In[69]:


# 負の値を持つ要素を0に変更
x1[x1 < 0] = 0
x1


# In[70]:


# 2で割り切れる要素を2倍
x1[x1 % 2==0] *= 2
x1


# In[71]:


x2 = np.arange(9).reshape(3, 3)
x2


# In[73]:


# 4以上の要素を10に変更
x2[x2 >= 4] = 10
x2


# ### 演習問題

# 以下の配列`x`から指定した条件を満たす要素を抽出せよ

# In[94]:


np.random.seed(seed=5)
x = np.random.randint(-100, 100, 100)
x


# In[ ]:


# 負の値を持つ要素


# In[ ]:


# 3の倍数


# In[ ]:


# 10以上50未満


# In[ ]:


# 10以下または50以上


# 以下の配列`x`から指定された配列を作成せよ．

# In[95]:


np.random.seed(seed=30)
x = np.random.randint(-10, 10, [5, 3])
x


# ```python
# # 3を20に変更
# array([[-5, -5, 20],
#        [20,  2, -8],
#        [ 7,  4, -7],
#        [-1, -3, -9],
#        [ 7, 20, -7]])
# ```

# In[ ]:





# ```python
# # 3と-5を0に変更
# array([[ 0,  0,  0],
#        [ 0,  2, -8],
#        [ 7,  4, -7],
#        [-1, -3, -9],
#        [ 7,  0, -7]])
# ```

# In[ ]:





# ```python
# # 負の値を全て-1に変更
# array([[-1, -1,  3],
#        [ 3,  2, -1],
#        [ 7,  4, -1],
#        [-1, -1, -1],
#        [ 7,  3, -1]])
# ```

# In[ ]:





# ```python
# # 負の値を全て正に変更
# array([[5, 5, 3],
#        [3, 2, 8],
#        [7, 4, 7],
#        [1, 3, 9],
#        [7, 3, 7]])
# ```

# In[ ]:





# ## 配列の形状変更
# 
# 付録を参照のこと：{ref}`numpy_change_shape`

# ## NumPy配列の演算

# ### ユニバーサル関数（ufunc）

# NumPy配列の演算（加減乗除など）は，`for`文で実装すると非常に低速になってしまう．そこで，高速な演算が可能な**ユニバーサル関数**が用意されている．これは，**配列に対して１つの関数を実行するだけで，全ての要素に対して演算が行われる機能**である．例えば，以下のように1000万個の数値が格納された1次元のNumPy配列があるとする．

# In[3]:


np.random.seed(seed=7)
D = np.random.randint(0, 100, size=int(1e7))
D


# いま，この1000万個の数値に対して平均値を求めようと思ったとき，最も単純な方法は以下のようなfor文による実装である：

# In[4]:


get_ipython().run_cell_magic('time', '', 'M = 0\nfor i in range(len(D)):\n    M += D[i]\n    \nprint(M / len(D))\n')


# 実行結果を見ると，平均を求めるという単純な演算であるにも関わらず，数秒の時間がかかっている（実行時間はPCのスペックによって変動する）．これは，データ数が非常に大きいことが原因である．
# 
# 一方，NumPyには平均値を求めるためのユニバーサル関数`numpy.mean`が用意されている．これを用いると，上のように配列の各要素にアクセスすることなく関数を1回実行するだけで平均値を求めることができる：

# In[5]:


get_ipython().run_cell_magic('time', '', 'np.mean(D)\n')


# この場合の実行時間はfor文を用いた場合の1/100以下となっていることがわかる（実行時間はPCのスペックによって変動する）．
# 
# このように，NumPyのユニバーサル関数を使った演算は，配列のサイズが大きくなるにつれてfor文を用いた場合よりもずっと効率的になる．そこで，**Pythonのプログラムでfor文を見つけたら，まずはNumPyのユニバーサル関数で置き換えられるかどうかを検討することが重要である**．

# ### 配列の演算規則

# NumPy配列の演算規則は以下のようにまとめられる：
# - NumPy配列と数値の演算では，配列の全ての要素に演算が適用される
# - 同じ形状を持つ２つの配列の演算では，**各配列の同じ要素同士で演算が行われる**．
# - 異なる形状を持つ配列の演算には特別な規則（**ブロードキャスト**）が適用される．
#   ※ 詳しくは付録を参照のこと：{ref}`numpy_fancy_index`

# #### 配列と数値の演算
# 
# まず，配列と数値の演算は，配列の全ての要素に演算が適用される．

# In[77]:


# 配列の生成
x2 = np.array([[1, 2, 3], [4, 5, 6]])
x2


# In[78]:


# 足し算
x2 + 5


# In[79]:


# 引き算
x2 - 5


# In[80]:


# 掛け算
x2 * 2 


# In[81]:


# 割り算
x2 / 2


# In[82]:


# 累乗
x2 ** 2


# In[83]:


# 余り
x2 % 2


# In[84]:


# 加減乗除
2*(x2 + 5 - 2)/3


# #### 同じ形状を持つ配列間の演算
# 
# 次に，同じ形状をもつ２つの配列の演算では，**各配列の同じ要素同士で演算が行われる**．

# In[85]:


# 配列の生成
x2 = np.array([[1, 2, 3], [4, 5, 6]])
x2


# In[86]:


# 同じ要素同士の足し算
x2 + x2


# In[87]:


# 同じ要素同士の引き算
x2 - x2


# In[88]:


# 同じ要素同士の掛け算
x2 * x2


# In[89]:


# 同じ要素同士の割り算
x2 / x2


# ### 様々なユニバーサル関数

# #### 並び替え（ソート）：`np.sort`

# 元の配列を変更せずにソートされた配列を得るには`np.sort`関数を使用する．

# In[90]:


# 配列の生成
x1 = np.random.randint(0, 100, 10)
x1


# In[91]:


np.sort(x1)


# 2次元配列の場合，`axis`を指定することで行ごとや列ごとのソートが実現できる．

# In[92]:


# 配列の生成
x2 = np.random.randint(0, 10, [5, 3])
x2


# In[93]:


# 列ごとにソート
np.sort(x2, axis=0)


# In[94]:


# 行ごとにソート
np.sort(x2, axis=1)


# #### 重複の削除：`np.unique`

# In[95]:


# 配列の生成
x1 = np.random.randint(0, 10, 100)
x1


# In[96]:


np.unique(x1)


# #### 絶対値：`np.abs`

# In[97]:


# 配列の生成
x = np.array([-2, -1, 0, 1, 2])


# In[98]:


np.abs(x)


# #### 三角関数

# In[99]:


# πの取得
np.pi


# In[100]:


# 角度データの生成
theta = np.array([np.pi/6, np.pi/3, np.pi/2, np.pi])


# In[101]:


# ラジアンから°への変換
np.degrees(theta)


# In[102]:


# sin
np.sin(theta)


# In[103]:


# cos
np.cos(theta)


# In[104]:


# tan
np.tan(theta)


# #### 指数関数

# In[105]:


x = np.array([1, 2, 3])


# In[106]:


# 平方根
np.sqrt(x)


# In[107]:


# 2^x
np.power(2, x)


# In[108]:


# e^x
np.power(np.e, x)


# In[109]:


# e^x
np.exp(x)


# #### 対数関数

# In[110]:


# 底が2
x = np.array([2**2, 2**3, 2**4])
np.log2(x)


# In[111]:


# 常用対数（底が10）
x = np.array([10**2, 10**3, 10**4])
np.log10(x)


# In[112]:


# 自然対数（底がe）
x = np.exp([1, 2, 3])
np.log(x)


# ### 配列の集計
# 
# NumPyには，配列から平均値などの統計量を求めるためのさまざまな集計関数が用意されている．
# なお，`np.nansum`のように`nan`を付けると，欠損値（NaN値）を無視して計算を行うことができる．

# | 関数名 | 説明 |
# | ---- |---- |
# | `np.sum` | 要素の合計を計算する |
# | `np.prod` | 要素の積を計算する |
# | `np.mean` | 要素の平均値を計算する |
# | `np.std` | 要素の標準偏差を計算する |
# | `np.var` | 要素の分散を計算する |
# | `np.min` | 最小値を見つける |
# | `np.max` | 最大値を見つける |
# | `np.median` | 要素の中央値を計算する |
# | `np.percentile` | パーセンタイルを計算する |
# | `np.any` | いずれかの要素がTrueであるかを評価する |
# | `np.all` | すべての要素がTrueであるかを評価する |

# #### １次元配列の場合

# In[113]:


# 配列の生成
np.random.seed(seed=2)
x = np.random.randint(0, 100, 10000)
x


# In[114]:


# 合計
np.sum(x)


# In[115]:


# 最大値
np.max(x)


# In[116]:


# 最小値
np.min(x)


# In[117]:


# 中央値
np.median(x)


# In[118]:


# 平均値
np.mean(x)


# In[119]:


# 標準偏差
np.std(x)


# In[120]:


# 標本分散（nで割る）
np.var(x, ddof=0)


# In[121]:


# 不偏分散（n-1で割る）
np.var(x, ddof=1)


# #### 2次元の場合

# 2次元の場合は`axis`を指定することで，行ごと（`axis=0`），列ごと（`axis=1`）の集計が実現できる．

# In[122]:


# 配列の生成
np.random.seed(seed=1)
x2 = np.random.randint(0, 100, [5, 5])
x2


# In[123]:


# 行方向（列ごと）
np.max(x2, axis=0)


# In[124]:


# 列方向（行ごと）
np.max(x2, axis=1)


# ## ファイル入出力

# #### ファイルへの出力
# 
# NumPy配列`x`をファイルに出力するには`np.savetxt`関数を用いる．

# In[147]:


# 配列の生成
x = np.arange(25).reshape(5, 5)


# In[148]:


# 配列をcsv形式で保存する
np.savetxt('./array_ex.csv', x, fmt='%d', delimiter=',')  # 相対パスを指定


# `np.savetxt`にはフォーマット`fmt`，区切り文字`delimiter`，エンコーディング`encoding`などを指定できる．

# #### ファイルからの読み込み

# データをNumPy配列に読み込むには`np.loadtxt`関数を用いる．

# In[149]:


arr = np.loadtxt('./array_ex.csv', delimiter=',', dtype='float')  # 相対パスを指定
arr


# `np.loadtxt`には引数として区切り文字`delimiter`，データ型`dtype`，エンコーディング`encoding`などが指定できる．`delimiter`を省略するとデフォルト値のスペース' 'となる．

# ## 章末問題

# **問題A**
# 
# 以下のように，母平均5，母標準偏差0.5の正規分布に従うデータから100個を抽出した．

# In[6]:


# 配列の生成
np.random.seed(seed=45)
x = np.random.normal(5, 0.5, 100)
x


# このデータに対し，`np.mean`関数と`np.std`関数を用いて標本平均と標本標準偏差を求めると以下のようになった．

# In[126]:


np.mean(x)


# In[127]:


np.std(x)


# - NumPyの関数を使わずに`x`の標本平均を求め，上の結果と一致することを確かめよ．
# ただし，データ $ x = (x_{1}, x_{2}, \ldots, x_{n}) $ に対して，標本平均 $ \bar{x} $ は以下で定義される：
# 
# $$
#     \bar{x} = \frac{1}{n} \sum_{i=1}^{n} x_{i} = \frac{x_{1}+x_{2}+\cdots+x_{n}}{n}
# $$

# In[ ]:





# - NumPyの関数を使わずに`x`の標本標準偏差を求め，上の結果と一致することを確かめよ（NumPyの他の関数は用いても良い）．
# ただし，データ $ x = (x_{1}, x_{2}, \ldots, x_{n}) $ に対して，標本標準偏差 $ \bar{\sigma} $ は以下で定義される：
# 
# $$
#     \bar{\sigma} 
#     = \sqrt{\frac{1}{n} \sum_{i=1}^{n} (x_{i} - \bar{x})^2}
#     = \sqrt{ \frac{(x_{1}-\bar{x})^2+(x_{2}-\bar{x})^2+\cdots+(x_{n}-\bar{x})^2}{n} }
# $$

# In[ ]:





# **問題B**

# 次のcsvファイルをダウンロードし，カレントディレクトリに保存せよ：[player_England.csv](https://drive.google.com/uc?export=download&id=1C1jhTLnDg7ES3QClTf6LL34f8vXq-JgQ) <br>
# このファイルには，2017年度にイングランド・プレミアリーグに所属していた選手の選手ID，身長，体重のデータが保存されている．
# ただし，身長の単位はcm，体重の単位はkgである．
# 
# ※ 本データはPappalardoデータセットを加工したものである（詳細は{ref}`pappalardo`）．

# まず，このファイルをNumPy配列`D`に読み込む：

# In[151]:


# csvファイルを読み込む
D = np.loadtxt('./player_England.csv', delimiter=',', dtype='int')
D


# 配列`D`は第0列に選手ID，第1列に身長，第2列に体重が格納されている．
# 例えば，`D`の第0行目を見ると，選手IDが3319で身長180cm，体重76kgであることが分かる．
# このデータに対し，以下の問いに答えよ．

# - 選手IDが-1となっている要素はダミーデータである．`D`からダミーデータを削除し，改めて配列`D`とせよ．

# In[ ]:


# 解答欄


# - データに含まれる選手数を調べよ．

# In[ ]:


# 解答欄


# - 選手IDが703の選手の身長と体重を調べよ．<br>
# ※ この選手は吉田麻也選手である．2017年時点の体重と現在の体重を比較してみよ．

# In[ ]:


# 解答欄


# - 配列Dから選手ID，身長，体重のデータを抽出し，それぞれ`I`, `H`, `W`という配列に格納せよ．

# In[ ]:


I = 
H = 
W = 


# - 以下の方法により，身長の最小値，最大値を求めよ
#     - 配列`H`を昇順（小→大）に並び替え，先頭と末尾の要素を抽出する
#     - `np.min`，`np.max`関数を用いる

# In[ ]:


# Hを昇順に並び替えて先頭と末尾の要素を抽出


# In[ ]:


# np.min, np.maxを用いる


# - 肥満度を表す指標としてBMIが知られている．BMIは身長と体重を用いて以下で定義される：
# \begin{align}
#     \mathrm{BMI} = \frac{体重 [kg]}{(身長 [m])^2}
# \end{align}

# - 身長の単位をcmからmに変換し，`H2`に格納せよ．

# In[ ]:


# Hの単位をcm -> m
H2 = 


# - 配列`W`と`H2`からBMIを求め，`BMI`という配列に格納せよ．

# In[ ]:


# BMIを求める
BMI = 


# - BMIが18.5未満の選手が１人いる．この選手のIDを調べよ．<br>
#   ※ この選手はRekeem Jordan Harper選手である．<br>
#   ※ 日本肥満学会の基準では，BMIが18.5未満の場合を痩せ型と定義している．

# In[ ]:


# BMIが18.5未満を抽出

